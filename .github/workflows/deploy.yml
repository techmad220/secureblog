name: Secure Deployment with OIDC
on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - '.github/**'
      - '!.github/workflows/deploy.yml'

# Minimal permissions following principle of least privilege
permissions:
  id-token: write   # for OIDC token generation
  contents: read    # for checkout only
  # No other permissions granted
  
env:
  CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
  
jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.2.2
      
      - name: Setup Node.js
        uses: actions/setup-node@1e60f620b9541d16bece96c5465dc8ee9832be0b # v4.0.3
        with:
          node-version: '20'
          
      - name: Setup Go
        uses: actions/setup-go@41dfa10bad2bb2ae585af6ee5bb4d7d973ad74ed # v5.1.0
        with:
          go-version: '1.23.x'  # Updated to latest stable
          check-latest: true
          
      - name: Build site
        run: |
          go mod download
          go build -trimpath -ldflags="-w -s" -mod=readonly ./cmd
          make build
          
      - name: Generate integrity manifest
        run: |
          python3 scripts/generate-manifest.py dist/
          
      - name: Sign manifest with Cosign
        uses: sigstore/cosign-installer@dc72c7d5c4d10cd6bcb8cf6e3fd625a9e5e537da # v3.7.0
        
      - name: Sign integrity manifest
        env:
          COSIGN_EXPERIMENTAL: 1
        run: |
          cosign sign-blob dist/integrity-manifest.json \
            --output-signature dist/integrity-manifest.json.sig \
            --output-certificate dist/integrity-manifest.json.crt \
            --yes
            
      # MANDATORY: Verify SLSA provenance and attestations before any deployment
      - name: Download and verify SLSA provenance
        run: |
          echo "ðŸ” Verifying SLSA provenance before deployment..."
          
          # Install slsa-verifier
          go install github.com/slsa-framework/slsa-verifier/v2/cli/slsa-verifier@latest
          
          # Check if provenance exists (should be generated by previous job/workflow)
          if [ ! -f "dist/slsa-provenance.intoto.jsonl" ]; then
            echo "âŒ CRITICAL: No SLSA provenance found - BLOCKING DEPLOYMENT"
            echo "Deployment requires valid SLSA Level 3 provenance attestation"
            exit 1
          fi
          
          # Verify provenance against artifacts
          echo "Verifying provenance for all deployment artifacts..."
          
          artifacts=(
            "dist/admin-server"
            "dist/blog-generator" 
            "dist/site.tar.gz"
            "dist/manifest.json"
          )
          
          for artifact in "${artifacts[@]}"; do
            if [ ! -f "$artifact" ]; then
              echo "âŒ Missing artifact: $artifact"
              exit 1
            fi
            
            echo "Verifying $artifact..."
            slsa-verifier verify-artifact "$artifact" \
              --provenance-path dist/slsa-provenance.intoto.jsonl \
              --source-uri github.com/${{ github.repository }} \
              --source-tag ${GITHUB_REF_NAME} || {
              echo "âŒ CRITICAL: Provenance verification failed for $artifact"
              echo "DEPLOYMENT BLOCKED - Artifact attestation invalid"
              exit 1
            }
          done
          
          echo "âœ… All artifacts have valid SLSA provenance"
          
      - name: Verify Cosign signatures
        run: |
          echo "ðŸ” Verifying Cosign signatures..."
          
          # Install cosign
          go install github.com/sigstore/cosign/v2/cmd/cosign@latest
          
          artifacts_to_verify=(
            "dist/integrity-manifest.json"
            "dist/admin-server"
            "dist/blog-generator"
          )
          
          for artifact in "${artifacts_to_verify[@]}"; do
            sig_file="${artifact}.sig"
            cert_file="${artifact}.crt"
            
            if [ ! -f "$sig_file" ] || [ ! -f "$cert_file" ]; then
              echo "âŒ CRITICAL: Missing signature files for $artifact"
              echo "DEPLOYMENT BLOCKED - All artifacts must be signed"
              exit 1
            fi
            
            echo "Verifying signature for $artifact..."
            cosign verify-blob "$artifact" \
              --signature "$sig_file" \
              --certificate "$cert_file" \
              --certificate-identity-regexp=".*" \
              --certificate-oidc-issuer-regexp=".*" || {
              echo "âŒ CRITICAL: Signature verification failed for $artifact"  
              echo "DEPLOYMENT BLOCKED - Invalid signature"
              exit 1
            }
          done
          
          echo "âœ… All signatures verified successfully"
          
      - name: Verify SBOM exists and is valid
        run: |
          echo "ðŸ” Verifying Software Bill of Materials..."
          
          if [ ! -f "dist/sbom.spdx.json" ]; then
            echo "âŒ CRITICAL: No SBOM found - BLOCKING DEPLOYMENT"
            echo "All deployments must include a valid SBOM"
            exit 1
          fi
          
          # Validate SBOM format
          if ! jq empty dist/sbom.spdx.json 2>/dev/null; then
            echo "âŒ CRITICAL: Invalid SBOM JSON format"
            exit 1
          fi
          
          # Check SBOM has required fields
          required_fields=(".spdxVersion" ".creationInfo" ".packages")
          for field in "${required_fields[@]}"; do
            if ! jq -e "$field" dist/sbom.spdx.json >/dev/null; then
              echo "âŒ CRITICAL: SBOM missing required field: $field"
              exit 1
            fi
          done
          
          echo "âœ… SBOM validation successful"
          
      # Fail-closed deployment gate
      - name: Deployment Security Gate
        run: |
          echo "ðŸš¦ DEPLOYMENT SECURITY GATE"
          echo "=========================="
          echo ""
          echo "âœ… SLSA provenance verified"
          echo "âœ… Cosign signatures verified" 
          echo "âœ… SBOM validated"
          echo "âœ… All attestations present and valid"
          echo ""
          echo "ðŸš€ DEPLOYMENT APPROVED - All security gates passed"
          echo ""
          echo "Deployment will FAIL CLOSED if any attestation is missing or invalid."
          
      - name: Configure AWS credentials (for OIDC)
        if: ${{ env.USE_AWS == 'true' }}
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: us-east-1
          
      - name: Get Cloudflare API Token via OIDC
        id: cf-token
        run: |
          # Get GitHub OIDC token
          OIDC_TOKEN=$(curl -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "$ACTIONS_ID_TOKEN_REQUEST_URL" | jq -r '.value')
          
          # Exchange for Cloudflare token (configure in Cloudflare dashboard)
          # This assumes you've set up OIDC federation in Cloudflare
          echo "::add-mask::$OIDC_TOKEN"
          echo "CF_OIDC_TOKEN=$OIDC_TOKEN" >> $GITHUB_ENV
          
      - name: Deploy to Cloudflare
        env:
          CF_API_TOKEN: ${{ env.CF_OIDC_TOKEN }}
        run: |
          npm install -g wrangler
          ./scripts/deploy-cloudflare.sh
          
      - name: Verify deployment
        run: |
          sleep 30  # Wait for CDN propagation
          
          # Check site is live
          curl -sf https://secureblog.com || exit 1
          
          # Verify security headers
          headers=$(curl -sI https://secureblog.com)
          echo "$headers" | grep -q "Content-Security-Policy" || exit 1
          echo "$headers" | grep -q "X-Frame-Options: DENY" || exit 1
          
          # Verify integrity manifest
          curl -sf https://secureblog.com/integrity-manifest.json || exit 1
          
      - name: Purge CDN cache
        if: success()
        env:
          CF_API_TOKEN: ${{ env.CF_OIDC_TOKEN }}
        run: |
          # Purge Cloudflare cache
          curl -X POST "https://api.cloudflare.com/client/v4/zones/${{ secrets.CF_ZONE_ID }}/purge_cache" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"purge_everything":true}'
            
      - name: Create deployment record
        if: success()
        run: |
          cat > deployment-record.json << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "commit": "${{ github.sha }}",
            "deployer": "${{ github.actor }}",
            "environment": "production",
            "integrity_manifest": "$(sha256sum dist/integrity-manifest.json | cut -d' ' -f1)"
          }
          EOF
          
      - name: Notify deployment
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… Deployment successful to Cloudflare"
          else
            echo "âŒ Deployment failed"
          fi