name: Secure Deployment with OIDC
on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - '.github/**'
      - '!.github/workflows/deploy.yml'

# Minimal permissions following principle of least privilege
permissions:
  id-token: write          # for OIDC token generation
  contents: read           # for checkout only
  attestations: write      # for GitHub Artifact Attestations
  packages: read           # for dependency access
  # No other permissions granted
  
env:
  CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
  
jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.2.2
      
      - name: Setup Node.js
        uses: actions/setup-node@1e60f620b9541d16bece96c5465dc8ee9832be0b # v4.0.3
        with:
          node-version: '20'
          
      - name: Setup Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5.5.0
        with:
          go-version: '1.23.x'  # Updated to latest stable
          check-latest: true
          
      - name: Build site with reproducible settings
        env:
          # Enforce reproducible builds with deterministic SOURCE_DATE_EPOCH
          SOURCE_DATE_EPOCH: ${{ github.event.head_commit.timestamp && github.event.head_commit.timestamp || github.run_started_at }}
          TZ: UTC
          LC_ALL: C
          CGO_ENABLED: 0
          GOOS: linux
          GOARCH: amd64
        run: |
          # Set umask for reproducible file permissions
          umask 022
          
          echo "ðŸ”¨ Building with reproducible settings..."
          echo "SOURCE_DATE_EPOCH: $SOURCE_DATE_EPOCH"
          echo "Commit: ${{ github.sha }}"
          
          # Download and verify modules in read-only mode
          go mod download
          go mod verify
          
          # Build with deterministic flags
          BUILD_VERSION="${{ github.sha }}"
          BUILD_DATE=$(date -u -d "@${SOURCE_DATE_EPOCH}" '+%Y-%m-%dT%H:%M:%SZ')
          
          go build \
            -trimpath \
            -buildvcs=false \
            -mod=readonly \
            -ldflags="-w -s -X main.Version=${BUILD_VERSION} -X main.BuildDate=${BUILD_DATE}" \
            -o dist/admin-server \
            ./cmd/admin-server/
            
          go build \
            -trimpath \
            -buildvcs=false \
            -mod=readonly \
            -ldflags="-w -s -X main.Version=${BUILD_VERSION} -X main.BuildDate=${BUILD_DATE}" \
            -o dist/blog-generator \
            ./cmd/blog-generator/
          
          # Generate static site
          ./dist/blog-generator \
            -input=content \
            -output=dist/public \
            -templates=templates \
            -deterministic=true
          
          # Create deterministic tarball
          cd dist/public
          find . -type f -exec touch -d "@${SOURCE_DATE_EPOCH}" {} \;
          tar \
            --sort=name \
            --mtime="@${SOURCE_DATE_EPOCH}" \
            --owner=0 \
            --group=0 \
            --numeric-owner \
            -czf ../site.tar.gz .
          cd ../..
          
      - name: Generate SBOM
        run: |
          echo "ðŸ“‹ Generating Software Bill of Materials..."
          
          # Install SPDX tools
          go install github.com/spdx/tools-golang/cmd/spdx-tool@latest
          
          # Generate Go SBOM
          go list -json -deps ./... > go-deps.json
          
          # Create comprehensive SBOM
          cat > dist/sbom.spdx.json << EOF
          {
            "spdxVersion": "SPDX-2.3",
            "dataLicense": "CC0-1.0",
            "SPDXID": "SPDXRef-DOCUMENT",
            "creationInfo": {
              "created": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
              "creators": ["Tool: SecureBlog-CI"],
              "licenseListVersion": "3.20"
            },
            "name": "SecureBlog",
            "documentNamespace": "https://github.com/${{ github.repository }}/sbom/${{ github.sha }}",
            "packages": [
              {
                "SPDXID": "SPDXRef-Package",
                "name": "SecureBlog",
                "downloadLocation": "https://github.com/${{ github.repository }}/archive/${{ github.sha }}.tar.gz",
                "filesAnalyzed": false,
                "copyrightText": "NOASSERTION",
                "versionInfo": "${{ github.sha }}"
              }
            ]
          }
          EOF
          
          echo "âœ… SBOM generated"
          
      - name: Create immutable release manifest
        run: |
          echo "ðŸ“¦ Creating immutable release manifest..."
          
          # Create comprehensive manifest
          cat > dist/release-manifest.json << EOF
          {
            "release": {
              "version": "${{ github.sha }}",
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
              "source_date_epoch": "$SOURCE_DATE_EPOCH",
              "repository": "${{ github.repository }}",
              "commit": "${{ github.sha }}",
              "ref": "${{ github.ref }}",
              "workflow_run": "${{ github.run_id }}",
              "actor": "${{ github.actor }}"
            },
            "artifacts": {
              "admin-server": {
                "path": "dist/admin-server",
                "sha256": "$(sha256sum dist/admin-server | cut -d' ' -f1)",
                "size": $(stat -c%s dist/admin-server)
              },
              "blog-generator": {
                "path": "dist/blog-generator", 
                "sha256": "$(sha256sum dist/blog-generator | cut -d' ' -f1)",
                "size": $(stat -c%s dist/blog-generator)
              },
              "site": {
                "path": "dist/site.tar.gz",
                "sha256": "$(sha256sum dist/site.tar.gz | cut -d' ' -f1)",
                "size": $(stat -c%s dist/site.tar.gz)
              },
              "sbom": {
                "path": "dist/sbom.spdx.json",
                "sha256": "$(sha256sum dist/sbom.spdx.json | cut -d' ' -f1)",
                "size": $(stat -c%s dist/sbom.spdx.json)
              }
            },
            "build_info": {
              "go_version": "$(go version | cut -d' ' -f3)",
              "build_flags": "-trimpath -buildvcs=false -mod=readonly",
              "environment": {
                "SOURCE_DATE_EPOCH": "$SOURCE_DATE_EPOCH",
                "TZ": "UTC",
                "LC_ALL": "C",
                "CGO_ENABLED": "0"
              }
            }
          }
          EOF
          
          echo "âœ… Release manifest created"
          
      - name: Generate build provenance attestation
        uses: actions/attest-build-provenance@1c608d11d69870c2092266b3f9a6f3abbf17002c # v1.4.3
        with:
          subject-path: |
            dist/admin-server
            dist/blog-generator
            dist/site.tar.gz
            dist/sbom.spdx.json
            dist/release-manifest.json
            
      - name: Sign artifacts with Cosign
        uses: sigstore/cosign-installer@dc72c7d5c4d10cd6bcb8cf6e3fd625a9e5e537da # v3.7.0
        
      - name: Sign all release artifacts
        env:
          COSIGN_EXPERIMENTAL: 1
        run: |
          echo "ðŸ”‘ Signing all release artifacts..."
          
          artifacts=(
            "dist/admin-server"
            "dist/blog-generator"  
            "dist/site.tar.gz"
            "dist/sbom.spdx.json"
            "dist/release-manifest.json"
          )
          
          for artifact in "${artifacts[@]}"; do
            echo "Signing: $artifact"
            cosign sign-blob "$artifact" \
              --output-signature "${artifact}.sig" \
              --output-certificate "${artifact}.crt" \
              --yes
          done
          
          echo "âœ… All artifacts signed"
            
      # MANDATORY: Verify GitHub Artifact Attestations before any deployment
      - name: Verify GitHub Artifact Attestations
        run: |
          echo "ðŸ” Verifying GitHub Artifact Attestations before deployment..."
          
          # Install GitHub CLI for attestation verification
          gh --version
          
          # Verify build provenance attestations for all artifacts
          artifacts=(
            "dist/admin-server"
            "dist/blog-generator" 
            "dist/site.tar.gz"
            "dist/sbom.spdx.json"
            "dist/release-manifest.json"
          )
          
          for artifact in "${artifacts[@]}"; do
            if [ ! -f "$artifact" ]; then
              echo "âŒ CRITICAL: Missing artifact: $artifact"
              echo "DEPLOYMENT BLOCKED - Required artifact not found"
              exit 1
            fi
            
            echo "Verifying GitHub attestation for: $artifact"
            
            # Verify the artifact has a valid GitHub attestation
            if ! gh attestation verify "$artifact" --repo "${{ github.repository }}"; then
              echo "âŒ CRITICAL: GitHub attestation verification failed for $artifact"
              echo "DEPLOYMENT BLOCKED - Artifact attestation invalid or missing"
              exit 1
            fi
          done
          
          echo "âœ… All artifacts have valid GitHub attestations"
          
      - name: Verify Cosign signatures
        run: |
          echo "ðŸ” Verifying Cosign signatures..."
          
          artifacts_to_verify=(
            "dist/admin-server"
            "dist/blog-generator"
            "dist/site.tar.gz"
            "dist/sbom.spdx.json"
            "dist/release-manifest.json"
          )
          
          for artifact in "${artifacts_to_verify[@]}"; do
            sig_file="${artifact}.sig"
            cert_file="${artifact}.crt"
            
            if [ ! -f "$sig_file" ] || [ ! -f "$cert_file" ]; then
              echo "âŒ CRITICAL: Missing signature files for $artifact"
              echo "DEPLOYMENT BLOCKED - All artifacts must be signed"
              exit 1
            fi
            
            echo "Verifying signature for $artifact..."
            cosign verify-blob "$artifact" \
              --signature "$sig_file" \
              --certificate "$cert_file" \
              --certificate-identity-regexp=".*" \
              --certificate-oidc-issuer-regexp=".*" || {
              echo "âŒ CRITICAL: Signature verification failed for $artifact"  
              echo "DEPLOYMENT BLOCKED - Invalid signature"
              exit 1
            }
          done
          
          echo "âœ… All signatures verified successfully"
          
      - name: Verify SBOM exists and is valid
        run: |
          echo "ðŸ” Verifying Software Bill of Materials..."
          
          if [ ! -f "dist/sbom.spdx.json" ]; then
            echo "âŒ CRITICAL: No SBOM found - BLOCKING DEPLOYMENT"
            echo "All deployments must include a valid SBOM"
            exit 1
          fi
          
          # Validate SBOM format
          if ! jq empty dist/sbom.spdx.json 2>/dev/null; then
            echo "âŒ CRITICAL: Invalid SBOM JSON format"
            exit 1
          fi
          
          # Check SBOM has required fields
          required_fields=(".spdxVersion" ".creationInfo" ".packages")
          for field in "${required_fields[@]}"; do
            if ! jq -e "$field" dist/sbom.spdx.json >/dev/null; then
              echo "âŒ CRITICAL: SBOM missing required field: $field"
              exit 1
            fi
          done
          
          echo "âœ… SBOM validation successful"
          
      # MANDATORY: Verify exact artifact digest before deployment
      - name: Generate and verify artifact digests
        run: |
          echo "ðŸ” Generating artifact digests for verification..."
          
          # Generate digests for all deployment artifacts
          sha256sum dist/site.tar.gz > dist/site.tar.gz.digest
          sha256sum dist/sbom.spdx.json > dist/sbom.spdx.json.digest
          sha256sum dist/release-manifest.json > dist/release-manifest.json.digest
          
          echo "ðŸ“‹ Artifact digests:"
          cat dist/*.digest
          
          # Store digests for attestation verification
          SITE_DIGEST=$(sha256sum dist/site.tar.gz | cut -d' ' -f1)
          SBOM_DIGEST=$(sha256sum dist/sbom.spdx.json | cut -d' ' -f1)
          MANIFEST_DIGEST=$(sha256sum dist/release-manifest.json | cut -d' ' -f1)
          
          echo "SITE_DIGEST=$SITE_DIGEST" >> $GITHUB_ENV
          echo "SBOM_DIGEST=$SBOM_DIGEST" >> $GITHUB_ENV
          echo "MANIFEST_DIGEST=$MANIFEST_DIGEST" >> $GITHUB_ENV
          
      # Verify SLSA provenance against exact artifact digests
      - name: Verify SLSA provenance for exact artifacts
        run: |
          echo "ðŸ” Verifying SLSA provenance against exact artifact digests..."
          
          # Download and verify SLSA provenance
          if ! gh attestation verify dist/site.tar.gz --repo "${{ github.repository }}" --digest-alg sha256; then
            echo "âŒ CRITICAL: SLSA provenance verification FAILED for site.tar.gz"
            echo "Digest: $SITE_DIGEST"
            echo "DEPLOYMENT BLOCKED - Cannot deploy without valid provenance"
            exit 1
          fi
          
          if ! gh attestation verify dist/sbom.spdx.json --repo "${{ github.repository }}" --digest-alg sha256; then
            echo "âŒ CRITICAL: SLSA provenance verification FAILED for sbom.spdx.json"
            echo "Digest: $SBOM_DIGEST"
            echo "DEPLOYMENT BLOCKED - Cannot deploy without valid SBOM provenance"
            exit 1
          fi
          
          if ! gh attestation verify dist/release-manifest.json --repo "${{ github.repository }}" --digest-alg sha256; then
            echo "âŒ CRITICAL: SLSA provenance verification FAILED for release-manifest.json"
            echo "Digest: $MANIFEST_DIGEST"
            echo "DEPLOYMENT BLOCKED - Cannot deploy without valid manifest provenance"
            exit 1
          fi
          
          echo "âœ… All artifacts have valid SLSA provenance for exact digests"
          
      # Verify Cosign signatures against exact digests
      - name: Verify Cosign signatures for exact artifacts  
        run: |
          echo "ðŸ” Verifying Cosign signatures against exact artifact digests..."
          
          # Verify signatures using digests
          artifacts_to_verify=(
            "dist/admin-server"
            "dist/blog-generator"
            "dist/site.tar.gz"
            "dist/sbom.spdx.json"
            "dist/release-manifest.json"
          )
          
          for artifact in "${artifacts_to_verify[@]}"; do
            sig_file="${artifact}.sig"
            cert_file="${artifact}.crt"
            
            if [ ! -f "$sig_file" ] || [ ! -f "$cert_file" ]; then
              echo "âŒ CRITICAL: Missing signature files for $artifact"
              echo "DEPLOYMENT BLOCKED - All artifacts must be signed"
              exit 1
            fi
            
            # Get artifact digest
            artifact_digest=$(sha256sum "$artifact" | cut -d' ' -f1)
            echo "Verifying signature for $artifact (digest: $artifact_digest)"
            
            if ! cosign verify-blob "$artifact" \
                --signature "$sig_file" \
                --certificate "$cert_file" \
                --certificate-identity-regexp=".*" \
                --certificate-oidc-issuer-regexp="https://token.actions.githubusercontent.com"; then
              echo "âŒ CRITICAL: Signature verification FAILED for $artifact"  
              echo "Artifact digest: $artifact_digest"
              echo "DEPLOYMENT BLOCKED - Invalid signature"
              exit 1
            fi
            
            echo "âœ… Signature verified for $artifact"
          done
          
          echo "âœ… All signatures verified successfully for exact artifact digests"
          
      # Final fail-closed deployment gate
      - name: Deployment Security Gate (Fail-Closed)
        run: |
          echo "ðŸš¦ DEPLOYMENT SECURITY GATE - FAIL-CLOSED VERIFICATION"
          echo "======================================================"
          echo ""
          echo "âœ… SLSA provenance verified for exact artifact digests"
          echo "âœ… Cosign signatures verified for exact artifact digests" 
          echo "âœ… SBOM validated and attested"
          echo "âœ… All deployment artifacts cryptographically verified"
          echo ""
          echo "ðŸ“‹ Verified Artifacts:"
          echo "  â€¢ site.tar.gz (digest: $SITE_DIGEST)"
          echo "  â€¢ sbom.spdx.json (digest: $SBOM_DIGEST)" 
          echo "  â€¢ release-manifest.json (digest: $MANIFEST_DIGEST)"
          echo ""
          echo "ðŸš€ DEPLOYMENT APPROVED - All fail-closed security gates passed"
          echo ""
          echo "âš ï¸  CRITICAL: This deployment will FAIL if:"
          echo "   - Any signature is invalid or missing"
          echo "   - SLSA provenance cannot be verified"
          echo "   - Artifact digests don't match attestations"
          echo "   - SBOM is missing or invalid"
          echo ""
          echo "ðŸ”’ Zero-trust deployment: Only cryptographically verified artifacts deployed"
          
      - name: Configure AWS credentials (for OIDC)
        if: ${{ env.USE_AWS == 'true' }}
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: us-east-1
          
      - name: Get Cloudflare API Token via OIDC
        id: cf-token
        run: |
          # Get GitHub OIDC token
          OIDC_TOKEN=$(curl -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "$ACTIONS_ID_TOKEN_REQUEST_URL" | jq -r '.value')
          
          # Exchange for Cloudflare token (configure in Cloudflare dashboard)
          # This assumes you've set up OIDC federation in Cloudflare
          echo "::add-mask::$OIDC_TOKEN"
          echo "CF_OIDC_TOKEN=$OIDC_TOKEN" >> $GITHUB_ENV
          
      - name: Deploy to Cloudflare
        env:
          CF_API_TOKEN: ${{ env.CF_OIDC_TOKEN }}
        run: |
          npm install -g wrangler
          ./scripts/deploy-cloudflare.sh
          
      - name: Verify deployment
        run: |
          sleep 30  # Wait for CDN propagation
          
          # Check site is live
          curl -sf https://secureblog.com || exit 1
          
          # Verify security headers
          headers=$(curl -sI https://secureblog.com)
          echo "$headers" | grep -q "Content-Security-Policy" || exit 1
          echo "$headers" | grep -q "X-Frame-Options: DENY" || exit 1
          
          # Verify integrity manifest
          curl -sf https://secureblog.com/integrity-manifest.json || exit 1
          
      - name: Purge CDN cache
        if: success()
        env:
          CF_API_TOKEN: ${{ env.CF_OIDC_TOKEN }}
        run: |
          # Purge Cloudflare cache
          curl -X POST "https://api.cloudflare.com/client/v4/zones/${{ secrets.CF_ZONE_ID }}/purge_cache" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"purge_everything":true}'
            
      - name: Create deployment record
        if: success()
        run: |
          cat > deployment-record.json << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "commit": "${{ github.sha }}",
            "deployer": "${{ github.actor }}",
            "environment": "production",
            "integrity_manifest": "$(sha256sum dist/integrity-manifest.json | cut -d' ' -f1)"
          }
          EOF
          
      - name: Notify deployment
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… Deployment successful to Cloudflare"
          else
            echo "âŒ Deployment failed"
          fi