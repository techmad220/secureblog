name: Secure Deployment with OIDC
on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - '.github/**'
      - '!.github/workflows/deploy.yml'

# Minimal permissions following principle of least privilege
permissions:
  id-token: write          # for OIDC token generation
  contents: read           # for checkout only
  attestations: write      # for GitHub Artifact Attestations
  packages: read           # for dependency access
  # No other permissions granted
  
env:
  CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
  
jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.2.2
      
      - name: Setup Node.js
        uses: actions/setup-node@1e60f620b9541d16bece96c5465dc8ee9832be0b # v4.0.3
        with:
          node-version: '20'
          
      - name: Setup Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5.5.0
        with:
          go-version: '1.23.x'  # Updated to latest stable
          check-latest: true
          
      - name: Build site with reproducible settings
        env:
          # Enforce reproducible builds with deterministic SOURCE_DATE_EPOCH
          SOURCE_DATE_EPOCH: ${{ github.event.head_commit.timestamp && github.event.head_commit.timestamp || github.run_started_at }}
          TZ: UTC
          LC_ALL: C
          CGO_ENABLED: 0
          GOOS: linux
          GOARCH: amd64
        run: |
          # Set umask for reproducible file permissions
          umask 022
          
          echo "🔨 Building with reproducible settings..."
          echo "SOURCE_DATE_EPOCH: $SOURCE_DATE_EPOCH"
          echo "Commit: ${{ github.sha }}"
          
          # Download and verify modules in read-only mode
          go mod download
          go mod verify
          
          # Build with deterministic flags
          BUILD_VERSION="${{ github.sha }}"
          BUILD_DATE=$(date -u -d "@${SOURCE_DATE_EPOCH}" '+%Y-%m-%dT%H:%M:%SZ')
          
          go build \
            -trimpath \
            -buildvcs=false \
            -mod=readonly \
            -ldflags="-w -s -X main.Version=${BUILD_VERSION} -X main.BuildDate=${BUILD_DATE}" \
            -o dist/admin-server \
            ./cmd/admin-server/
            
          go build \
            -trimpath \
            -buildvcs=false \
            -mod=readonly \
            -ldflags="-w -s -X main.Version=${BUILD_VERSION} -X main.BuildDate=${BUILD_DATE}" \
            -o dist/blog-generator \
            ./cmd/blog-generator/
          
          # Generate static site
          ./dist/blog-generator \
            -input=content \
            -output=dist/public \
            -templates=templates \
            -deterministic=true
          
          # Create deterministic tarball
          cd dist/public
          find . -type f -exec touch -d "@${SOURCE_DATE_EPOCH}" {} \;
          tar \
            --sort=name \
            --mtime="@${SOURCE_DATE_EPOCH}" \
            --owner=0 \
            --group=0 \
            --numeric-owner \
            -czf ../site.tar.gz .
          cd ../..
          
      - name: Generate SBOM
        run: |
          echo "📋 Generating Software Bill of Materials..."
          
          # Install SPDX tools
          go install github.com/spdx/tools-golang/cmd/spdx-tool@latest
          
          # Generate Go SBOM
          go list -json -deps ./... > go-deps.json
          
          # Create comprehensive SBOM
          cat > dist/sbom.spdx.json << EOF
          {
            "spdxVersion": "SPDX-2.3",
            "dataLicense": "CC0-1.0",
            "SPDXID": "SPDXRef-DOCUMENT",
            "creationInfo": {
              "created": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
              "creators": ["Tool: SecureBlog-CI"],
              "licenseListVersion": "3.20"
            },
            "name": "SecureBlog",
            "documentNamespace": "https://github.com/${{ github.repository }}/sbom/${{ github.sha }}",
            "packages": [
              {
                "SPDXID": "SPDXRef-Package",
                "name": "SecureBlog",
                "downloadLocation": "https://github.com/${{ github.repository }}/archive/${{ github.sha }}.tar.gz",
                "filesAnalyzed": false,
                "copyrightText": "NOASSERTION",
                "versionInfo": "${{ github.sha }}"
              }
            ]
          }
          EOF
          
          echo "✅ SBOM generated"
          
      - name: Create immutable release manifest
        run: |
          echo "📦 Creating immutable release manifest..."
          
          # Create comprehensive manifest
          cat > dist/release-manifest.json << EOF
          {
            "release": {
              "version": "${{ github.sha }}",
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
              "source_date_epoch": "$SOURCE_DATE_EPOCH",
              "repository": "${{ github.repository }}",
              "commit": "${{ github.sha }}",
              "ref": "${{ github.ref }}",
              "workflow_run": "${{ github.run_id }}",
              "actor": "${{ github.actor }}"
            },
            "artifacts": {
              "admin-server": {
                "path": "dist/admin-server",
                "sha256": "$(sha256sum dist/admin-server | cut -d' ' -f1)",
                "size": $(stat -c%s dist/admin-server)
              },
              "blog-generator": {
                "path": "dist/blog-generator", 
                "sha256": "$(sha256sum dist/blog-generator | cut -d' ' -f1)",
                "size": $(stat -c%s dist/blog-generator)
              },
              "site": {
                "path": "dist/site.tar.gz",
                "sha256": "$(sha256sum dist/site.tar.gz | cut -d' ' -f1)",
                "size": $(stat -c%s dist/site.tar.gz)
              },
              "sbom": {
                "path": "dist/sbom.spdx.json",
                "sha256": "$(sha256sum dist/sbom.spdx.json | cut -d' ' -f1)",
                "size": $(stat -c%s dist/sbom.spdx.json)
              }
            },
            "build_info": {
              "go_version": "$(go version | cut -d' ' -f3)",
              "build_flags": "-trimpath -buildvcs=false -mod=readonly",
              "environment": {
                "SOURCE_DATE_EPOCH": "$SOURCE_DATE_EPOCH",
                "TZ": "UTC",
                "LC_ALL": "C",
                "CGO_ENABLED": "0"
              }
            }
          }
          EOF
          
          echo "✅ Release manifest created"
          
      - name: Generate build provenance attestation
        uses: actions/attest-build-provenance@1c608d11d69870c2092266b3f9a6f3abbf17002c # v1.4.3
        with:
          subject-path: |
            dist/admin-server
            dist/blog-generator
            dist/site.tar.gz
            dist/sbom.spdx.json
            dist/release-manifest.json
            
      - name: Sign artifacts with Cosign
        uses: sigstore/cosign-installer@dc72c7d5c4d10cd6bcb8cf6e3fd625a9e5e537da # v3.7.0
        
      - name: Sign all release artifacts
        env:
          COSIGN_EXPERIMENTAL: 1
        run: |
          echo "🔑 Signing all release artifacts..."
          
          artifacts=(
            "dist/admin-server"
            "dist/blog-generator"  
            "dist/site.tar.gz"
            "dist/sbom.spdx.json"
            "dist/release-manifest.json"
          )
          
          for artifact in "${artifacts[@]}"; do
            echo "Signing: $artifact"
            cosign sign-blob "$artifact" \
              --output-signature "${artifact}.sig" \
              --output-certificate "${artifact}.crt" \
              --yes
          done
          
          echo "✅ All artifacts signed"
            
      # MANDATORY: Verify GitHub Artifact Attestations before any deployment
      - name: Verify GitHub Artifact Attestations
        run: |
          echo "🔍 Verifying GitHub Artifact Attestations before deployment..."
          
          # Install GitHub CLI for attestation verification
          gh --version
          
          # Verify build provenance attestations for all artifacts
          artifacts=(
            "dist/admin-server"
            "dist/blog-generator" 
            "dist/site.tar.gz"
            "dist/sbom.spdx.json"
            "dist/release-manifest.json"
          )
          
          for artifact in "${artifacts[@]}"; do
            if [ ! -f "$artifact" ]; then
              echo "❌ CRITICAL: Missing artifact: $artifact"
              echo "DEPLOYMENT BLOCKED - Required artifact not found"
              exit 1
            fi
            
            echo "Verifying GitHub attestation for: $artifact"
            
            # Verify the artifact has a valid GitHub attestation
            if ! gh attestation verify "$artifact" --repo "${{ github.repository }}"; then
              echo "❌ CRITICAL: GitHub attestation verification failed for $artifact"
              echo "DEPLOYMENT BLOCKED - Artifact attestation invalid or missing"
              exit 1
            fi
          done
          
          echo "✅ All artifacts have valid GitHub attestations"
          
      - name: Verify Cosign signatures
        run: |
          echo "🔍 Verifying Cosign signatures..."
          
          artifacts_to_verify=(
            "dist/admin-server"
            "dist/blog-generator"
            "dist/site.tar.gz"
            "dist/sbom.spdx.json"
            "dist/release-manifest.json"
          )
          
          for artifact in "${artifacts_to_verify[@]}"; do
            sig_file="${artifact}.sig"
            cert_file="${artifact}.crt"
            
            if [ ! -f "$sig_file" ] || [ ! -f "$cert_file" ]; then
              echo "❌ CRITICAL: Missing signature files for $artifact"
              echo "DEPLOYMENT BLOCKED - All artifacts must be signed"
              exit 1
            fi
            
            echo "Verifying signature for $artifact..."
            cosign verify-blob "$artifact" \
              --signature "$sig_file" \
              --certificate "$cert_file" \
              --certificate-identity-regexp=".*" \
              --certificate-oidc-issuer-regexp=".*" || {
              echo "❌ CRITICAL: Signature verification failed for $artifact"  
              echo "DEPLOYMENT BLOCKED - Invalid signature"
              exit 1
            }
          done
          
          echo "✅ All signatures verified successfully"
          
      - name: Verify SBOM exists and is valid
        run: |
          echo "🔍 Verifying Software Bill of Materials..."
          
          if [ ! -f "dist/sbom.spdx.json" ]; then
            echo "❌ CRITICAL: No SBOM found - BLOCKING DEPLOYMENT"
            echo "All deployments must include a valid SBOM"
            exit 1
          fi
          
          # Validate SBOM format
          if ! jq empty dist/sbom.spdx.json 2>/dev/null; then
            echo "❌ CRITICAL: Invalid SBOM JSON format"
            exit 1
          fi
          
          # Check SBOM has required fields
          required_fields=(".spdxVersion" ".creationInfo" ".packages")
          for field in "${required_fields[@]}"; do
            if ! jq -e "$field" dist/sbom.spdx.json >/dev/null; then
              echo "❌ CRITICAL: SBOM missing required field: $field"
              exit 1
            fi
          done
          
          echo "✅ SBOM validation successful"
          
      # MANDATORY: Verify exact artifact digest before deployment
      - name: Generate and verify artifact digests
        run: |
          echo "🔍 Generating artifact digests for verification..."
          
          # Generate digests for all deployment artifacts
          sha256sum dist/site.tar.gz > dist/site.tar.gz.digest
          sha256sum dist/sbom.spdx.json > dist/sbom.spdx.json.digest
          sha256sum dist/release-manifest.json > dist/release-manifest.json.digest
          
          echo "📋 Artifact digests:"
          cat dist/*.digest
          
          # Store digests for attestation verification
          SITE_DIGEST=$(sha256sum dist/site.tar.gz | cut -d' ' -f1)
          SBOM_DIGEST=$(sha256sum dist/sbom.spdx.json | cut -d' ' -f1)
          MANIFEST_DIGEST=$(sha256sum dist/release-manifest.json | cut -d' ' -f1)
          
          echo "SITE_DIGEST=$SITE_DIGEST" >> $GITHUB_ENV
          echo "SBOM_DIGEST=$SBOM_DIGEST" >> $GITHUB_ENV
          echo "MANIFEST_DIGEST=$MANIFEST_DIGEST" >> $GITHUB_ENV
          
      # Verify SLSA provenance against exact artifact digests
      - name: Verify SLSA provenance for exact artifacts
        run: |
          echo "🔍 Verifying SLSA provenance against exact artifact digests..."
          
          # Download and verify SLSA provenance
          if ! gh attestation verify dist/site.tar.gz --repo "${{ github.repository }}" --digest-alg sha256; then
            echo "❌ CRITICAL: SLSA provenance verification FAILED for site.tar.gz"
            echo "Digest: $SITE_DIGEST"
            echo "DEPLOYMENT BLOCKED - Cannot deploy without valid provenance"
            exit 1
          fi
          
          if ! gh attestation verify dist/sbom.spdx.json --repo "${{ github.repository }}" --digest-alg sha256; then
            echo "❌ CRITICAL: SLSA provenance verification FAILED for sbom.spdx.json"
            echo "Digest: $SBOM_DIGEST"
            echo "DEPLOYMENT BLOCKED - Cannot deploy without valid SBOM provenance"
            exit 1
          fi
          
          if ! gh attestation verify dist/release-manifest.json --repo "${{ github.repository }}" --digest-alg sha256; then
            echo "❌ CRITICAL: SLSA provenance verification FAILED for release-manifest.json"
            echo "Digest: $MANIFEST_DIGEST"
            echo "DEPLOYMENT BLOCKED - Cannot deploy without valid manifest provenance"
            exit 1
          fi
          
          echo "✅ All artifacts have valid SLSA provenance for exact digests"
          
      # Verify Cosign signatures against exact digests
      - name: Verify Cosign signatures for exact artifacts  
        run: |
          echo "🔍 Verifying Cosign signatures against exact artifact digests..."
          
          # Verify signatures using digests
          artifacts_to_verify=(
            "dist/admin-server"
            "dist/blog-generator"
            "dist/site.tar.gz"
            "dist/sbom.spdx.json"
            "dist/release-manifest.json"
          )
          
          for artifact in "${artifacts_to_verify[@]}"; do
            sig_file="${artifact}.sig"
            cert_file="${artifact}.crt"
            
            if [ ! -f "$sig_file" ] || [ ! -f "$cert_file" ]; then
              echo "❌ CRITICAL: Missing signature files for $artifact"
              echo "DEPLOYMENT BLOCKED - All artifacts must be signed"
              exit 1
            fi
            
            # Get artifact digest
            artifact_digest=$(sha256sum "$artifact" | cut -d' ' -f1)
            echo "Verifying signature for $artifact (digest: $artifact_digest)"
            
            if ! cosign verify-blob "$artifact" \
                --signature "$sig_file" \
                --certificate "$cert_file" \
                --certificate-identity-regexp=".*" \
                --certificate-oidc-issuer-regexp="https://token.actions.githubusercontent.com"; then
              echo "❌ CRITICAL: Signature verification FAILED for $artifact"  
              echo "Artifact digest: $artifact_digest"
              echo "DEPLOYMENT BLOCKED - Invalid signature"
              exit 1
            fi
            
            echo "✅ Signature verified for $artifact"
          done
          
          echo "✅ All signatures verified successfully for exact artifact digests"
          
      # Final fail-closed deployment gate
      - name: Deployment Security Gate (Fail-Closed)
        run: |
          echo "🚦 DEPLOYMENT SECURITY GATE - FAIL-CLOSED VERIFICATION"
          echo "======================================================"
          echo ""
          echo "✅ SLSA provenance verified for exact artifact digests"
          echo "✅ Cosign signatures verified for exact artifact digests" 
          echo "✅ SBOM validated and attested"
          echo "✅ All deployment artifacts cryptographically verified"
          echo ""
          echo "📋 Verified Artifacts:"
          echo "  • site.tar.gz (digest: $SITE_DIGEST)"
          echo "  • sbom.spdx.json (digest: $SBOM_DIGEST)" 
          echo "  • release-manifest.json (digest: $MANIFEST_DIGEST)"
          echo ""
          echo "🚀 DEPLOYMENT APPROVED - All fail-closed security gates passed"
          echo ""
          echo "⚠️  CRITICAL: This deployment will FAIL if:"
          echo "   - Any signature is invalid or missing"
          echo "   - SLSA provenance cannot be verified"
          echo "   - Artifact digests don't match attestations"
          echo "   - SBOM is missing or invalid"
          echo ""
          echo "🔒 Zero-trust deployment: Only cryptographically verified artifacts deployed"
          
      - name: Configure AWS credentials (for OIDC)
        if: ${{ env.USE_AWS == 'true' }}
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: us-east-1
          
      - name: Get Cloudflare API Token via OIDC
        id: cf-token
        run: |
          # Get GitHub OIDC token
          OIDC_TOKEN=$(curl -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "$ACTIONS_ID_TOKEN_REQUEST_URL" | jq -r '.value')
          
          # Exchange for Cloudflare token (configure in Cloudflare dashboard)
          # This assumes you've set up OIDC federation in Cloudflare
          echo "::add-mask::$OIDC_TOKEN"
          echo "CF_OIDC_TOKEN=$OIDC_TOKEN" >> $GITHUB_ENV
          
      - name: Deploy to Cloudflare
        env:
          CF_API_TOKEN: ${{ env.CF_OIDC_TOKEN }}
        run: |
          npm install -g wrangler
          ./scripts/deploy-cloudflare.sh
          
      - name: Verify deployment
        run: |
          sleep 30  # Wait for CDN propagation
          
          # Check site is live
          curl -sf https://secureblog.com || exit 1
          
          # Verify security headers
          headers=$(curl -sI https://secureblog.com)
          echo "$headers" | grep -q "Content-Security-Policy" || exit 1
          echo "$headers" | grep -q "X-Frame-Options: DENY" || exit 1
          
          # Verify integrity manifest
          curl -sf https://secureblog.com/integrity-manifest.json || exit 1
          
      - name: Purge CDN cache
        if: success()
        env:
          CF_API_TOKEN: ${{ env.CF_OIDC_TOKEN }}
        run: |
          # Purge Cloudflare cache
          curl -X POST "https://api.cloudflare.com/client/v4/zones/${{ secrets.CF_ZONE_ID }}/purge_cache" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"purge_everything":true}'
            
      - name: Create deployment record
        if: success()
        run: |
          cat > deployment-record.json << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "commit": "${{ github.sha }}",
            "deployer": "${{ github.actor }}",
            "environment": "production",
            "integrity_manifest": "$(sha256sum dist/integrity-manifest.json | cut -d' ' -f1)"
          }
          EOF
          
      - name: Notify deployment
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✅ Deployment successful to Cloudflare"
          else
            echo "❌ Deployment failed"
          fi